== More on pods

Pods are good for more than just organization though. A pod also
containerizes the network communication between the containers within
it.

If we run the same httpd container from earlier, without putting it
inside of a pod, we can then access whatever ports we have exposed on
the container, via localhost on our container host.

[source,bash,run,subs=attributes+]
----
podman run -d -p 8080:80 --rm --name my-bare-httpd httpd
----

This tells podman to run the same container image, with a new name, and
forward port 8080 on our host, to port 80 on the container.

Now if we look at `+podman ps+` again, we’ll see a new httpd container,
notice that it says its listening on `+0.0.0.0:8080+`

[source,bash,run,subs=attributes+]
----
podman ps
----

[source,text]
----
[rhel@rhel ~]$ podman ps
CONTAINER ID  IMAGE                                    COMMAND           CREATED         STATUS         PORTS                 NAMES
672a12919c13  localhost/podman-pause:5.4.0-1750809600                    11 minutes ago  Up 6 minutes                         9abe9e47a2a4-infra
04446f8062d6  docker.io/library/httpd:latest           httpd-foreground  6 minutes ago   Up 6 minutes   80/tcp                my-httpd
a27afba43bf9  docker.io/library/httpd:latest           httpd-foreground  51 seconds ago  Up 52 seconds  0.0.0.0:8080->80/tcp  my-bare-httpd
[rhel@rhel ~]$
----

And we can even test that out with `+curl+`

[source,bash,run,subs=attributes+]
----
curl http://127.0.0.1:8080
----
[source,text]
----
[rhel@rhel ~]$ curl http://127.0.0.1:8080
<html><body><h1>It works!</h1></body></html>
[rhel@rhel ~]$
----

Lets try to make a new httpd container, inside of our pod, that forwards
in the same way. First let’s stop our new httpd container.

[source,bash,run,subs=attributes+]
----
podman stop my-bare-httpd
----

Now, we still have an httpd container running, but we can’t access it,
not just because we havent forwarded any ports to it, but because its
inside of a pod. The pod acts almost like a firewall, allowing or
disallowing ports to the containers within it. Containers that run
container images that are configured to listen on a given port are
accessible to each other within the pod, but outside the pod are not
accessible unless we tell the pod to allow it.

== Pod networking

Let’s run a container that lets us get to a bash shell within our
podfrom earlier, to show that the httpd service is in fact accessible,
just not from outside the pod.

[source,bash,run,subs=attributes+]
----
podman run -it --pod my-pod --rm registry.access.redhat.com/ubi9/ubi
----

In this example, we’re running a container, interactively, insdie of our
pod. You should get to a bash prompt inside of a RHEL UBI container.
[source,text]
----
[rhel@rhel ~]$ podman stop my-bare-httpd
my-bare-httpd
[rhel@rhel ~]$ podman run -it --pod my-pod --rm registry.access.redhat.com/ubi9/ubi
[root@my-pod /]# 
----

This container doesn’t run any services, but if we try to use curl on
localhost, we’ll see that in fact we get a response!

[source,bash,run,subs=attributes+]
----
curl http://127.0.0.1
----

[source,text]
----
[root@my-pod /]# curl http://127.0.0.1
<html><body><h1>It works!</h1></body></html>
[root@my-pod /]# 
----
You can exit that shell with

[source,bash,run,subs=attributes+]
----
exit
----

So let’s re-create our pod, and make it listen on port 8080. Let’s stop,
and then delete our pod.

[source,bash,run,subs=attributes+]
----
podman pod stop my-pod && podman pod rm my-pod
----

Now let’s make a new pod, with a new httpd container, and have the pod
forward port 8080 to port 80 inside the pod.

[source,bash,run,subs=attributes+]
----
podman pod create --name my-networked-pod -p 8080:80
----

And then we’ll need a container to listen on port 80, but we don’t need
to tell the container to forward anything, that’s handled at the pod
level.

[source,bash,run,subs=attributes+]
----
podman run -d --pod my-networked-pod --name my-networked-httpd httpd
----

Now, if we check `+podman pod ps+` and `+podman ps+` we’ll see that both
the pod container, and the container itself show the port 8080 forward,
even though we didnt specify that on the container.

[source,bash,run,subs=attributes+]
----
podman pod ps
----
[source,text]
----
[rhel@rhel ~]$ podman pod ps
POD ID        NAME              STATUS      CREATED         INFRA ID      # OF CONTAINERS
e6171893814b  my-networked-pod  Running     14 seconds ago  0cb63867153a  2
[rhel@rhel ~]$
----

[source,bash,run,subs=attributes+]
----
podman ps
----
[source,text]
----
[rhel@rhel ~]$ podman ps
CONTAINER ID  IMAGE                                    COMMAND           CREATED             STATUS             PORTS                 NAMES
0cb63867153a  localhost/podman-pause:5.4.0-1750809600                    About a minute ago  Up About a minute  0.0.0.0:8080->80/tcp  e6171893814b-infra
57e1ac2f658b  docker.io/library/httpd:latest           httpd-foreground  About a minute ago  Up About a minute  0.0.0.0:8080->80/tcp  my-networked-httpd
[rhel@rhel ~]$
----

And we should be able to test that with `+curl+` now.

[source,bash,run,subs=attributes+]
----
curl http://127.0.0.1:8080
----

[source,text]
----
[rhel@rhel ~]$ curl http://127.0.0.1:8080
<html><body><h1>It works!</h1></body></html>
[rhel@rhel ~]$ 
----

In our next step, we’ll look at how to operationalize pod deployements
using kubelets!
